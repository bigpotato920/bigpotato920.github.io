<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="bigpotato" />
        <meta name="copyright" content="bigpotato" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="leetcode, algorithm, tree, java, algorithm, " />

<meta property="og:title" content="二叉树的遍历问题总结 "/>
<meta property="og:url" content="http://bigpotato920.github.io/tree_traversal.html" />
<meta property="og:description" content="对二叉树深度优先和广度优先遍历问题的总结" />
<meta property="og:site_name" content="bigpotato&#39;s blog" />
<meta property="og:article:author" content="bigpotato" />
<meta property="og:article:published_time" content="2014-02-20T00:00:00+08:00" />
<meta property="" content="2014-02-20T00:00:00+08:00" />
<meta name="twitter:title" content="二叉树的遍历问题总结 ">
<meta name="twitter:description" content="对二叉树深度优先和广度优先遍历问题的总结">

        <title>二叉树的遍历问题总结  · bigpotato&#39;s blog
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://bigpotato920.github.io/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://bigpotato920.github.io/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://bigpotato920.github.io/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://bigpotato920.github.io/theme/css/custom.css" media="screen">
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="http://bigpotato920.github.io/"><span class=site-name>bigpotato's blog</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://bigpotato920.github.io">Home</a></li>
                            <li ><a href="http://bigpotato920.github.io/categories.html">Categories</a></li>
                            <li ><a href="http://bigpotato920.github.io/tags.html">Tags</a></li>
                            <li ><a href="http://bigpotato920.github.io/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="http://bigpotato920.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="http://bigpotato920.github.io/tree_traversal.html"> 二叉树的遍历问题总结  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            
            <h2>二叉树的遍历问题总结</h2>
<p>二叉树的遍历主要有：</p>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<p>其中深度优先遍历又包括：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<p>深度优先遍历分为递归和非递归的实现方式，广度优先遍历就是层次遍历，根据二叉树的遍历方式的组合可以重二叉树，下面对这些问题进行一个总结。</p>
<h3>前序遍历</h3>
<blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes' values.
For example:
Given binary tree <code>{1,#,2,3}</code>,</p>
<p><code>1
  \
   2
  /
 3</code></p>
<p>return <code>[1,2,3]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<p><a href="https://oj.leetcode.com/problems/binary-tree-preorder-traversal/"><strong>Leetcode 前序遍历题目地址</strong></a></p>
<p>前序遍历非递归可以用一个栈来实现，由于遍历过程中要先访问树的左子树，而后右子树，所以实现的时候先把根节点的右孩子入栈，而后是左孩子。</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">preorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<h3>中序遍历</h3>
<blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes' values.
For example:
Given binary tree <code>{1,#,2,3}</code>,</p>
<p><code>1
  \
   2
  /
 3</code></p>
<p>return <code>[1,3,2]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<p><a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/"><strong>Leetcode 中序遍历题目地址</strong></a></p>
<p>二叉树中序遍历非递归也是利用栈来完成，由于二叉树中序遍历要先遍历左孩子而后根节点，最后是右孩子。所以算法先找到根节点的最左孩子，把一路下来的左孩子依次入栈，访问最左孩子，而后是访问根节点，然后把根节点右孩子当做当前节点重复上述过程直到节点都访问完。代码如下：</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">inorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="n">TreeNode</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">cur_node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">stack</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">cur_node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur_node</span><span class="o">);</span>
                <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">cur_node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<h3>后序遍历</h3>
<blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes' values.
For example:
Given binary tree <code>{1,#,2,3}</code>,</p>
<p><code>1
  \
   2
  /
 3</code></p>
<p>return <code>[3,2,1]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<p><a href="https://oj.leetcode.com/problems/binary-tree-postorder-traversal/"><strong>Leetcode 后序遍历题目地址</strong></a></p>
<p>二叉树后序遍历非递归可以通过两个栈来实现，具体代码如下：</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>

        <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">TreeNode</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur_node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

            <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">cur_node</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">s2</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">pop</span><span class="o">().</span><span class="na">val</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<p>二叉树后序遍历非递归还可以通过一个栈来和一个访问前驱标志来实现，通过这个标志为来判断根节点的右子树是否访问完，如果访问完则访问根节点，否则继续遍历右子树，代码如下：</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="n">TreeNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">//找到最左孩子</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="c1">//如果右子树没有被访问，访问右子树</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">right</span> <span class="o">!=</span> <span class="n">pre</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">right</span><span class="o">;</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="c1">//访问根节点</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">().</span><span class="na">val</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<p>二叉树后序遍历非递归还可以只通过一个栈来实现，代码如下：</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">postorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">empty</span><span class="o">());</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<h3>通过二叉树中序和后序遍历构建二叉树</h3>
<blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong></p>
<p>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<p><a href="https://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/"><strong>Leetcode题目地址</strong></a></p>
<p>对与如下的二叉树,其中序遍历序列和后序遍历序列分别为：</p>
<div class="highlight"><pre><span></span>        1
       / \
      2   3
     / \ / \
    4  5 6  7
</pre></div>


<p><strong>中序遍历:</strong>4 2 5 <code>1</code> 6 3 7</p>
<p><strong>后序遍历:</strong>4 5 2 6 7 3 <code>1</code></p>
<p>在后序遍历序列中最后一个元素即为二叉树根节点，在中序遍历序列中二叉树根节点把二叉树分成左右子树，左子树的根节点为根节点1的左孩子，右子树的根节点为根节点1的右孩子，这个过程具有良好的递归性。算法实现的代码如下：</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">postorder</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">buildTreeHelper</span><span class="o">(</span><span class="n">inorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span>
               <span class="n">postorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">postorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">TreeNode</span> <span class="nf">buildTreeHelper</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">in_begin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">in_end</span><span class="o">,</span>
                                     <span class="kt">int</span><span class="o">[]</span> <span class="n">postorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">post_begin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">post_end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">in_begin</span> <span class="o">&gt;</span> <span class="n">in_end</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">postorder</span><span class="o">[</span><span class="n">post_end</span><span class="o">]);</span>
        <span class="kt">int</span> <span class="n">in_index</span> <span class="o">=</span> <span class="n">in_begin</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">in_begin</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">in_end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">in_index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="o">(</span><span class="n">inorder</span><span class="o">,</span> <span class="n">in_begin</span><span class="o">,</span> <span class="n">in_index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span>
                <span class="n">postorder</span><span class="o">,</span> <span class="n">post_begin</span><span class="o">,</span> <span class="n">post_begin</span> <span class="o">+</span> <span class="n">in_index</span> <span class="o">-</span> <span class="n">in_begin</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="o">(</span><span class="n">inorder</span><span class="o">,</span> <span class="n">in_index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">in_end</span><span class="o">,</span>
                <span class="n">postorder</span><span class="o">,</span> <span class="n">post_begin</span> <span class="o">+</span> <span class="n">in_index</span> <span class="o">-</span> <span class="n">in_begin</span><span class="o">,</span> <span class="n">post_end</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<h3>通过二叉树前序遍历和中序遍历序列构建二叉树</h3>
<blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong></p>
<p>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<p><a href="https://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><strong>Leetcode 题目地址</strong></a></p>
<p>对与如下的二叉树,其前序遍历序列和中序遍历序列分别为：</p>
<div class="highlight"><pre><span></span>        1
       / \
      2   3
     / \ / \
    4  5 6  7
</pre></div>


<p><strong>前序遍历:</strong><code>1</code> 2 4 5 3 6 7</p>
<p><strong>中序遍历:</strong>4 2 5 <code>1</code> 6 3 7</p>
<p>这道题的思路和上一个题目类似，前序遍历序列第一个元素是整个二叉树的根节点元素，根据根节点元素可以把中序遍历序列分成两部分，分别用来构造二叉树的左右子树。具体代码如下：</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">buildTreeHelper</span><span class="o">(</span><span class="n">preorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span>
                <span class="n">inorder</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">TreeNode</span> <span class="nf">buildTreeHelper</span><span class="o">(</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pre_begin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pre_end</span><span class="o">,</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">in_begin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">in_end</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">pre_begin</span> <span class="o">&gt;</span> <span class="n">pre_end</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">TreeNode</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">pre_begin</span><span class="o">]);</span>
        <span class="kt">int</span> <span class="n">in_index</span> <span class="o">=</span> <span class="n">in_begin</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">in_begin</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">in_end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">in_index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="o">(</span>
                <span class="n">preorder</span><span class="o">,</span> <span class="n">pre_begin</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">pre_begin</span> <span class="o">+</span> <span class="n">in_index</span> <span class="o">-</span> <span class="n">in_begin</span><span class="o">,</span>
                <span class="n">inorder</span><span class="o">,</span> <span class="n">in_begin</span><span class="o">,</span> <span class="n">in_index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">buildTreeHelper</span><span class="o">(</span>
                <span class="n">preorder</span><span class="o">,</span> <span class="n">pre_begin</span> <span class="o">+</span> <span class="n">in_index</span> <span class="o">-</span> <span class="n">in_begin</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">pre_end</span><span class="o">,</span>
                <span class="n">inorder</span><span class="o">,</span> <span class="n">in_index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">in_end</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<h3>二叉树层次遍历</h3>
<blockquote>
<p>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</p>
<p>For example:</p>
<p>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<p><code>3
 / \ 
9  20
   /\
  15 7</code></p>
<p>return its level order traversal as:</p>
<p><code>[
  [3],
  [9, 20],
  [15, 7]
]</code></p>
</blockquote>
<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal/"><strong>Leetocode 二叉树层序遍历题目地址</strong></a></p>
<p>二叉树层序遍历可以采用队列来实现，但这道题要求求出每一层的序列，这里采用的方法是利用两个变量分别记录当前层的元素数目和下一层的元素数目。代码如下：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrder</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;();</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>

        <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">cur_level_count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">next_level_count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tmp_level</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">tmp_level</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

                <span class="n">next_level_count</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">;</span> 
            <span class="o">}</span>
            <span class="n">cur_level_count</span><span class="o">--;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">cur_level_count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">tmp_level</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">tmp_level</span><span class="o">));</span>
                    <span class="n">tmp_level</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
                    <span class="n">cur_level_count</span> <span class="o">=</span> <span class="n">next_level_count</span><span class="o">;</span>
                    <span class="n">next_level_count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:</p>
<p>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<p><code>3
 / \ 
9  20
   /\
  15 7</code></p>
<p>return its level order traversal as:</p>
<p><code>[
  [15, 7]
  [9, 20],
  [3]
]</code></p>
</blockquote>
<p><a href="https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/"><strong>Leetocode 二叉树层序遍历题目地址</strong></a></p>
<p>这道题目和上一题的思路类似，只是在把每一层的遍历结果插入result时采用头插法，就能得到逆序的层次遍历结果。</p>
            
            <section>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="http://bigpotato920.github.io/tree_traversal.html#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
                    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'bigpotato4future';
        var disqus_identifier = 'http://bigpotato920.github.io/tree_traversal.html';
    var disqus_url = 'http://bigpotato920.github.io/tree_traversal.html';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

                </div>
            </div>
        </div>
    </div>
</div>
</section>

            <hr/>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2014-02-20T00:00:00+08:00"> 2 20, 2014</time>

<h4>Last Updated</h4>
<time datetime="2014-02-20T00:00:00+08:00"> 2 20, 2014</time>

            <h4>Category</h4>
            <a class="category-link" href="http://bigpotato920.github.io/categories.html#algorithm-ref">algorithm</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="http://bigpotato920.github.io/tags.html#algorithm-ref">algorithm
                    <span>2</span>
</a></li>
                <li><a href="http://bigpotato920.github.io/tags.html#java-ref">java
                    <span>6</span>
</a></li>
                <li><a href="http://bigpotato920.github.io/tags.html#leetcode-ref">leetcode
                    <span>2</span>
</a></li>
                <li><a href="http://bigpotato920.github.io/tags.html#tree-ref">tree
                    <span>1</span>
</a></li>
            </ul>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

            <script type="text/javascript">
var disqus_shortname = 'bigpotato4future';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
<script  language="javascript" type="text/javascript">
function uncollapse() {
    if (window.location.hash.match(/^#comment-\d+$/)) {
        $('#disqus_thread').collapse('show');
    }
}
</script>
<script type="text/javascript" language="JavaScript">
uncollapse();
window.onhashchange=function(){
    if (window.location.hash.match(/^#comment-\d+$/))
        window.location.reload(true);
}
</script>
<script>
$('#disqus_thread').on('shown', function () {
    var link = document.getElementsByClassName('accordion-toggle');
    var old_innerHTML = link[0].innerHTML;
    $(link[0]).fadeOut(500, function() {
        $(this).text('Click here to hide comments').fadeIn(500);
    });
    $('#disqus_thread').on('hidden', function () {
        $(link[0]).fadeOut(500, function() {
            $(this).text(old_innerHTML).fadeIn(500);
        });
    })
})
</script>


    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>